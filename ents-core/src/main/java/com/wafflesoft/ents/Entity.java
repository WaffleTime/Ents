/* 
 * NOTICE OF LICENSE
 * 
 * This source file is subject to the Open Software License (OSL 3.0) that is 
 * bundled with this package in the file LICENSE.txt. It is also available 
 * through the world-wide-web at http://opensource.org/licenses/osl-3.0.php
 * If you did not receive a copy of the license and are unable to obtain it 
 * through the world-wide-web, please send an email to magnos.software@gmail.com 
 * so we can send you a copy immediately. If you use any of this software please
 * notify me via our website or email, your feedback is much appreciated. 
 * 
 * @copyright   Copyright (c) 2011 Magnos Software (http://www.magnos.org)
 * @license     http://opensource.org/licenses/osl-3.0.php
 * 				Open Software License (OSL 3.0)
 */

package com.wafflesoft.ents;

import com.wafflesoft.ents.util.*;


/**
 * An Entity is a game object that may be drawn, may be updated, has a set of
 * components, has a set of controllers that modifies it's state, and optionally
 * a view which handles the drawing. <br/>
 * <br/>
 * An entity by default is not expired, is visible, and is enabled. <br/>
 * <br/>
 * When an entity expires, the object containing the Entity is responsible from
 * removing it from the world. An expired Entity is one that is ready to be
 * entirely forgotten by the world and should not be drawn or updated. However,
 * an Entity could be expired and the {@link #update(Object)} and
 * {@link #draw(Object)} methods may still work, it's the job of the container
 * to check for expiration.
 *
 * @author Philip Diffenderfer
 */
@SuppressWarnings("unchecked")
public class Entity {

    /**
     * The unique non-negative identifier for this entity. This is generated by
     * {@link Ents} and is garunteed that no other active (non-deleted) entity
     * will have the same ID.
     *
     * @see IndexPool
     */
    public final int id;

    /**
     * The template of the Entity.
     */
    protected Template template;

    /**
     * The entity's distinct component values.
     */
    protected Object[] values;

    /**
     * Which controllers are enabled.
     */
    protected BitSet controllerEnabled;

    /**
     * The current Renderer of the entity.
     */
    protected Renderer renderer;

    /**
     * If the entity is expired, it is up for deletion by the parent Entity.
     */
    protected boolean expired = false;

    /**
     * If the entity is visible, the {@link #renderer} of the entity is
     * invoked when the {@link #draw(Object)} method is invoked.
     */
    protected boolean visible = true;

    /**
     * If the entity is enabled, the enabled controllers of the entity is
     * invoked when the {@link #update(Object)} method is invoked.
     */
    protected boolean enabled = true;

    /**
     * Instantiates a custom entity that by default does not have components,
     * controllers, or a view.
     */
    public Entity() {
        this(Ents.newTemplate());
    }

    /**
     * Instantiates a custom entity with a set of components, without any
     * controllers, and without a view.
     *
     * @param components The set of components to add to the Entity.
     */
    public Entity(Component<?>... components) {
        this(new ComponentSet(components), ControllerSet.NONE, View.NONE);
    }

    /**
     * Instantiates a custom entity with a set of components, controllers, and
     * without a view.
     *
     * @param componentSet  The set of components to add to the Entity.
     * @param controllerSet The set of controllers to add to the Entity.
     */
    public Entity(ComponentSet componentSet, ControllerSet controllerSet) {
        this(componentSet, controllerSet, View.NONE);
    }

    /**
     * Instantiates a custom entity with a set of components, controllers, and a
     * view.
     *
     * @param componentSet  The set of components to add to the Entity.
     * @param controllerSet The set of controllers to add to the Entity.
     * @param view          The view for the entity.
     */
    public Entity(ComponentSet componentSet, ControllerSet controllerSet, View view) {
        this(new Template(componentSet, controllerSet, view));
    }

    /**
     * Instantiates an Entity given a {@link Template}. This entity will have
     * the Template's components, controllers, and view. <br/>
     * <br/>
     * All controllers that exist in the Template are enabled by default on the
     * Entity. In other words, when update is called after Entity creation all
     * controllers will modify the Entity. To control which controllers are
     * enabled use the {@link #setControllerEnabled(Controller, boolean)} method
     * (or any of it's variants).
     *
     * @param template The template of the Entity.
     */
    public Entity(Template template) {
        this(template, template.createDefaultValues(), template.createRenderer());
    }

    /**
     * Instantiates an Entity given a template and the Entity's default values.
     *
     * @param template The template of the Entity.
     * @param values   The default values of the entity.
     */
    protected Entity(Template template, Object[] values, Renderer renderer) {
        this.setTemplate(template);
        this.values = values;
        this.controllerEnabled = new BitSet(template.controllers.length, true);
        this.id = Ents.register(this);
        this.template.addToComponents(this);
        this.setRenderer(renderer);
    }

    /**
     * Internally sets the Template of the entity notifying the existing
     * Template (if any) that it has one last Entity instance as well as
     * notifying the new Template that it has a new Entity instance. The given
     * template will always be either the same as the current template or an
     * extension of it. It should never be a template with fewer components or
     * controllers.
     *
     * @param newTemplate The new template of the Entity.
     * @return True if the template given is different than the existing
     * template.
     */
    private boolean setTemplate(Template newTemplate) {
        boolean changed = (template != newTemplate);

        if (changed) {
            if (template != null) {
                template.removeInstance(this);
            }

            (template = newTemplate).newInstance(this);
        }

        return changed;
    }

    /**
     * @return True if the Entity has expired, otherwise false.
     */
    public boolean isExpired() {
        return expired;
    }

    /**
     * Expires the entity, setting off the flag that let's any container know
     * that this Entity should no longer be held (or drawn and updated) and
     * {@link #delete()} should be invoked.
     */
    public void expire() {
        expired = true;
    }

    /**
     * This removes this Entity from the Template and destroys the Entity's
     * Renderer. Once this method is called, this Entity should not by used,
     * all methods will most likely result in a {@link NullPointerException}. <br/>
     * <br/>
     * If the entity is added to an Entity collection, delete will be called
     * whenever the {@link #update(Object)} or {@link EntityList#clean()} is
     * called and this entity is expired. It will also cause this entity to
     * removed from its container.
     */
    public boolean delete() {
        boolean deletable = (template != null);

        if (deletable) {
            if (renderer != null) {
                renderer.destroy(this);
            }

            Ents.unregister(this);

            template.removeFromComponents(this);
            template.removeInstance(this);

            template = null;
            renderer = null;
            expired = true;
        }

        return deletable;
    }

    /**
     * Determines whether this Entity has been deleted.
     *
     * @return True if the Entity has been deleted, otherwise false.
     */
    public boolean isDeleted() {
        return (template == null);
    }

    /**
     * Sets the visibility of this Entity to the given value.
     *
     * @param visible True if the {@link #draw(Object)} method should have any effect,
     *                otherwise false.
     */
    public void setVisible(boolean visible) {
        this.visible = visible;
    }

    /**
     * Sets the visibility of this Entity to true. If this entity has a view,
     * {@link Renderer#draw(Entity, Object)} will be called with the drawState
     * passed into draw as well as the reference to this Entity.
     */
    public void show() {
        visible = true;
    }

    /**
     * Sets the visibility of this Entity to false. This entity will not be
     * drawn.
     */
    public void hide() {
        visible = false;
    }

    /**
     * @return True if the Entity is visible, otherwise false.
     */
    public boolean isVisible() {
        return visible;
    }

    /**
     * Draws the Entity if it's visible and has a {@link View}, by passing the
     * drawState and this Entity to it's View.
     *
     * @param drawState An object to pass to the view which enables this Entity to be
     *                  drawn on the chosen medium.
     */
    public void draw(Object drawState) {
        if (visible && renderer != null) {
            renderer.begin(this, drawState);
            renderer.end(this, drawState);
        }
    }

    /**
     * Determines whether this Entity has the given view (or an alternative).
     * This returns whether the view passed in has the same ID as the current
     * view of the Entity, it does not check to see if it's literally the exact
     * same view.
     *
     * @param view The view to check for.
     * @return True if this Entity has the given view (or an alternative),
     * otherwise false.
     */
    public boolean has(View view) {
        return template.has(view);
    }

    /**
     * @return True if this Entity has a view at all, otherwise false.
     */
    public boolean hasView() {
        return template.hasView();
    }

    /**
     * Determines if this Entity has a non-null renderer. Even if the renderer
     * is non-null it might not be called if the entity is marked as invisible.
     *
     * @return True if this Entity has a non-null renderer.
     */
    public boolean hasRenderer() {
        return renderer != null;
    }

    /**
     * Returns the reference to the {@link Renderer} for this Entity. The
     * {@link Renderer#create(Entity)} and {@link Renderer#destroy(Entity)}
     * should not be called on the Renderer returned, it may negatively affect
     * the rendering of this Entity and even the application. <br/>
     * <br/>
     * The reference returned was created by invoking
     * {@link #setRenderer(Renderer)}, or by having a non-null view and causing
     * {@link Renderer#create(Entity)} to be called and the returned reference
     * be used.
     *
     * @return The reference to this Entity's renderer, or null.
     */
    public Renderer getRenderer() {
        return renderer;
    }

    /**
     * Returns the {@link View} associated with this Entity. The view holds the
     * {@link Renderer} that's responsible for drawing this Entity. Even if the
     * view is null this Entity can still have a Renderer if the
     * {@link #setRenderer(Renderer)} method was invoked with a non-null
     * Renderer.
     *
     * @return The reference to the View for this Entity.
     */
    public View getView() {
        return template.getView();
    }

    /**
     * Sets whether this entity is enabled or not. An enabled entity (true) will
     * invoke it's controllers when {@link #update(Object)} is called, while a
     * disabled entity (false) does not. <br/>
     * <br/>
     * Even if the entity is enabled, it's controllers need to be enabled as
     * well using the {@link #setControllerEnabled(Controller, boolean)} method
     * or it's variants.
     *
     * @param enabled True if the entity should be enabled, otherwise false.
     */
    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }

    /**
     * Enables this entity, calling any enabled controllers when
     * {@link #update(Object)} is called.
     *
     * @see #setEnabled(boolean)
     */
    public void enable() {
        enabled = true;
    }

    /**
     * Disables this entity, {@link #update(Object)} will have no affect.
     *
     * @see #setEnabled(boolean)
     */
    public void disable() {
        enabled = false;
    }

    /**
     * @return True if the entity is enabled, otherwise false.
     * @see #setEnabled(boolean)
     */
    public boolean isEnabled() {
        return enabled;
    }

    /**
     * Updates the Entity if it's enabled. To update an entity, all enabled
     * controllers on the Entity are invoked passing the Entity reference and
     * the given updateState.
     *
     * @param updateState An object to pass to the controller's control method.
     */
    public void update(Object updateState) {
        if (enabled) {
            final Controller[] controllers = template.controllers;

            for (int i = 0; i < controllers.length; i++) {
                final Controller c = controllers[i];

                if (controllerEnabled.get(template.indexOf(c))) {
                    c.control.update(this, updateState);
                }
            }
        }
    }

    /**
     * Determines whether the given {@link Controller} (or an alternative) is
     * enabled for this Entity. If the controller doesn't exist, an
     * {@link IndexOutOfBoundsException} will be thrown. To avoid an exception,
     * {@link #has(Controller)} should be tested first. If this method returns
     * true, {@link Control#update(Entity, Object)} is called on the controller
     * if {@link #isEnabled()} is true and {@link #update(Object)} is invoked.
     *
     * @param controller The controller to check for being enabled.
     * @return True if the controller exists in this Entity and it's enabled.
     */
    public boolean isControllerEnabled(Controller controller) {
        return controllerEnabled.get(template.indexOf(controller));
    }

    /**
     * Sets whether the given controller is enabled on this Entity. If this
     * Entity doesn't have the given Controller (or an alternative) then an
     * {@link IndexOutOfBoundsException} is thrown. To avoid an exception,
     * {@link #has(Controller)} should be tested first. An enabled controller
     * will have it's {@link Control#update(Entity, Object)} method invoked
     * if {@link #isEnabled()} is true and {@link #update(Object)} is invoked.
     *
     * @param controller The controller to enable or disable.
     * @param enabled    True to enable the controller, false to disable it.
     */
    public void setControllerEnabled(Controller controller, boolean enabled) {
        controllerEnabled.set(template.indexOf(controller), enabled);
    }

    /**
     * Enables or disables all controllers that exist in this Entity.
     *
     * @param enabled True if all controllers should be enabled, otherwise false.
     */
    public void setControllerEnabledAll(boolean enabled) {
        controllerEnabled.set(0, template.controllers.length, enabled);
    }

    /**
     * Enables the given controller on this Entity. If this Entity does not
     * have the controller (or an alternative) an IndexOutOfBoundsException will
     * be thrown.
     *
     * @param controller The controller to enable on this Entity.
     * @throws IndexOutOfBoundsException
     */
    public void enable(Controller controller) {
        setControllerEnabled(controller, true);
    }

    /**
     * Disables the given controller on this Entity. If this Entity does not
     * have the controller (or an alternative) an IndexOutOfBoundsException will
     * be thrown.
     *
     * @param controller The controller to enable on this Entity.
     * @throws IndexOutOfBoundsException
     */
    public void disable(Controller controller) {
        setControllerEnabled(controller, false);
    }

    /**
     * Determines whether this Entity has the given controller.
     *
     * @param controller The controller to test for existence.
     * @return True if the entity has the controller, otherwise false.
     */
    public boolean has(Controller controller) {
        return template.has(controller);
    }

    /**
     * Determines whether this Entity has all of the given controllers.
     *
     * @param controllers The array of controllers to test for existence.
     * @return True if the entity has all given controllers, otherwise false.
     */
    public boolean has(Controller... controllers) {
        return template.has(controllers);
    }

    /**
     * Determines whether this Entity has all of the given controllers
     * specified in the BitSet, where the 0th bit is the controller with
     * an ID of zero.
     *
     * @param controllers The BitSet of controller identifiers.
     * @return True if the entity has all given controllers, otherwise false.
     */
    public boolean hasControllers(BitSet controllers) {
        return template.controllerBitSet.contains(controllers);
    }

    /*
     * Component Functions
     */

    /**
     * Determines whether this entity has the given component (or an
     * alternative).
     *
     * @param component The component to test for.
     * @return True if this Entity has the component (or an alternative),
     * otherwise false.
     */
    public boolean has(Component<?> component) {
        return template.has(component);
    }

    /**
     * Determines whether this entity has all of the given components (or their
     * alternatives).
     *
     * @param components The set of components to test for.
     * @return True if this entity has all of the components (or their
     * alternatives), otherwise false.
     */
    public boolean has(Component<?>... components) {
        return template.has(components);
    }

    /**
     * Determines whether this entity has all of the given components specified
     * by a BitSet, where the i'th bit in the set is set to true to indicate the
     * component with the ID equaling "i" is present.
     *
     * @param components The BitSet of components.
     * @return True if this entity has all of the components specified in the
     * BitSet, otherwise false.
     */
    public boolean hasComponents(BitSet components) {
        return template.componentBitSet.contains(components);
    }

    /**
     * Returns the value of the component on this Entity. This is an unsafe
     * method, meaning if the Entity does not have the component then a
     * {@link NullPointerException} will be thrown. This method is also the
     * fastest way of getting an Entity's component value. <br/>
     * <br/>
     * {@link #gets(Component)} or {@link #gets(Component, Object)} should be
     * used to safely get a value of a component. <br/>
     * <br/>
     * Depending on the component type, the value returned may be a value that
     * is shared between all Entities that have the component, it may be shared
     * between all Entities that have the same Template, it may be a dynamically
     * created value, or it may be an aliased value (existing under a different
     * component in reality).
     *
     * @param component The component to get the value of.
     * @return The value of the component on this Entity.
     * @throws NullPointerException The component does not exist on this Entity.
     */
    public <T> T get(Component<T> component) {
        TemplateComponent<T> ch = (TemplateComponent<T>) template.handlers[component.id];
        return ch.get(this);
    }

    /**
     * Returns the value of the component on this Entity or null if this entity
     * does not have the given component. This is a safer, although slightly
     * slower, alternative to {@link #get(Component)}. An alternative method to
     * this is {@link #gets(Component, Object)} which returns a defined value if
     * the Entity doesn't have the component. <br/>
     * <br/>
     * {@link #get(Component)} should be used if you are confident an Entity has
     * the component, or if you want an exception to be thrown to indicate a
     * logical error in your code. <br/>
     * <br/>
     * The return value of null should not be used as an indicator to whether an
     * Entity has a component, since null is a valid component value. <br/>
     * <br/>
     * Depending on the component type, the value returned may be a value that
     * is shared between all Entities that have the component, it may be shared
     * between all Entities that have the same Template, it may be a dynamically
     * created value, or it may be an aliased value (existing under a different
     * component in reality).
     *
     * @param component The component to get the value of.
     * @return The value of the component on this Entity or null.
     */
    public <T> T gets(Component<T> component) {
        return template.has(component) ? get(component) : null;
    }

    /**
     * Returns the value of the component on this Entity or given missingValue
     * if this entity does not have the given component. This is a safer,
     * although slightly slower, alternative to {@link #get(Component)}. An
     * alternative method to this is {@link #gets(Component)} which returns null
     * if the Entity doesn't have the component. <br/>
     * <br/>
     * {@link #get(Component)} should be used if you are confident an Entity has
     * the component, or if you want an exception to be thrown to indicate a
     * logical error in your code. <br/>
     * <br/>
     * The return value matching (by reference) the missingValue passed in
     * should
     * not be used as an indicator to whether an Entity has a component, since
     * missingValue could actually exist on the Entity. <br/>
     * <br/>
     * Depending on the component type, the value returned may be a value that
     * is shared between all Entities that have the component, it may be shared
     * between all Entities that have the same Template, it may be a dynamically
     * created value, or it may be an aliased value (existing under a different
     * component in reality).
     *
     * @param component The component to get the value of.
     * @return The value of the component on this Entity or missingValue.
     */
    public <T> T gets(Component<T> component, T missingValue) {
        return template.has(component) ? get(component) : missingValue;
    }

    /**
     * Sets the value of the component on this Entity. This is an unsafe method,
     * meaning if the Entity does not have the component then a
     * {@link NullPointerException} will be thrown. This method is also the
     * fastest way of setting an Entity's component value. <br/>
     * <br/>
     * {@link #sets(Component, Object)} should be used to safely set the value
     * of a component on the Entity. <br/>
     * <br/>
     * Depending on the component type, the value set may be a value that is
     * shared between all Entities that have the component, it may be shared
     * between all Entities that have the same Template, it may be a dynamically
     * set value, or it may be an aliased value (existing under a different
     * component in reality).
     *
     * @param component The component to set the value of.
     * @param value     The new value of the component.
     * @throws NullPointerException The component does not exist on this Entity.
     */
    public <T> void set(Component<T> component, T value) {
        TemplateComponent<T> ch = (TemplateComponent<T>) template.handlers[component.id];
        ch.set(this, value);
    }

    /**
     * Sets the value of the component on this Entity and returns true, or
     * returns false if this Entity does not have the given component. This is a
     * safe yet slower alternative to {@link #set(Component, Object)}, thus will
     * not result in an exception being thrown. <br/>
     * <br/>
     * {@link #set(Component, Object)} should be used if you are confident an
     * Entity has the component, or if you want an exception to be thrown to
     * indicate a logical error in your code. <br/>
     * <br/>
     * Depending on the component type, the value set may be a value that is
     * shared between all Entities that have the component, it may be shared
     * between all Entities that have the same Template, it may be a dynamically
     * set value, or it may be an aliased value (existing under a different
     * component in reality).
     *
     * @param component The component to set the value of.
     * @param value     The new value of the component.
     * @return True if the Entity has the component and the value was set,
     * otherwise false.
     */
    public <T> boolean sets(Component<T> component, T value) {
        boolean has = template.has(component);

        if (has) {
            set(component, value);
        }

        return has;
    }

    /**
     * Sets target to the value of the given component on this Entity and
     * returns target. This is not a safe method and will result in a
     * {@link NullPointerException} if the entity does not contain the
     * component, however it is the quicker method. <br/>
     * <br/>
     * This is useful when a dynamic component could be in use, depending on the
     * {@link DynamicValue} implementation it may save on unnecessarily creating
     * a short-lived object. <br/>
     * <br/>
     * {@link #takes(Component, Object)} should be used as the safe alternative
     * to this method. <br/>
     * <br/>
     * Not all component types may support taking, therefore a reference to an
     * object other than target may be returned.
     *
     * @param component The component to take the value of.
     * @param target    The target value to set and return with the component's value.
     * @return The reference to target, or the reference to another object if
     * taking is not supported by the component on this Entity.
     * @throws NullPointerException The component does not exist on this Entity.
     */
    public <T> T take(Component<T> component, T target) {
        TemplateComponent<T> ch = (TemplateComponent<T>) template.handlers[component.id];
        return ch.take(this, target);
    }

    /**
     * Sets target to the value of the given component on this Entity and
     * returns target. This is the safe alternative to
     * {@link #take(Component, Object)} and will return null if this Entity does
     * not have the given component. <br/>
     * <br/>
     * This is useful when a dynamic component could be in use, depending on the
     * {@link DynamicValue} implementation it may save on unnecessarily creating
     * a short-lived object. <br/>
     * <br/>
     * {@link #take(Component, Object)} should be used if you are confident an
     * Entity has the component, or if you want an exception to be thrown to
     * indicate a logical error in your code. <br/>
     * <br/>
     * Not all component types may support taking, therefore a reference to an
     * object other than target may be returned.
     *
     * @param component The component to take the value of.
     * @param target    The target value to set and return with the component's value.
     * @return The reference to target, null, or the reference to another object
     * if taking is not supported by the component on this Entity.
     * @throws NullPointerException The component does not exist on this Entity.
     */
    public <T> T takes(Component<T> component, T target) {
        return has(component) ? take(component, target) : null;
    }

    /*
     * Dynamic Functions
     */

    /**
     * Dynamically adds the given component to this Entity. If this Entity
     * already has this component exactly, this method has no affect. If this
     * Entity already has an alternative to this component, then this method
     * will still create a template and replace the alternative with the
     * component given. If this Entity does not already have it's own Template,
     * one will be given. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively. <br/>
     * <br/>
     *
     * @param component The component to add or to replace the alternative with.
     */
    public <T> void add(Component<T> component) {
        setTemplate(template.addCustomComponent(component, this));
    }

    /**
     * Dynamically adds the given component to this Entity. If this Entity
     * already has this component exactly, this method has no affect. If this
     * Entity already has an alternative to this component, then this method
     * will still create a template and replace the alternative with the
     * component given. If this Entity does not already have it's own Template,
     * one will be given. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively.
     *
     * @param component    The component to add or to replace the alternative with.
     * @param defaultValue The default value for the component.
     * @see #add(Component)
     * @see #set(Component, Object)
     */
    public <T> void add(Component<T> component, T defaultValue) {
        add(component);
        set(component, defaultValue);
    }

    /**
     * Forces the value and component into this entity. If the given component
     * or an alternative doesn't exist, the given component is added to this
     * Entity. Once it's verified the component exists on the entity, the
     * component's value is set to the given value. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively.
     *
     * @param component The component to force on the entity.
     * @param value     The value of the forced component.
     * @return True if the component had to be added, otherwise false.
     */
    public <T> boolean put(Component<T> component, T value) {
        boolean missing = !template.has(component);

        if (missing) {
            add(component);
        }

        set(component, value);

        return missing;
    }

    /**
     * Forcefully takes the value of the component from this Entity. If the
     * given component or an alternative doesn't exist, the given component is
     * added to this Entity. Once it's verified the component exists on the
     * entity, the component's value is returned. In the event that the
     * component was dynamically added, the default value will be returned. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively.
     *
     * @param component The component to grab the value of, and potentially add to this
     *                  Entity if it doesn't exist already.
     * @return The grabbed value of the component on this Entity.
     */
    public <T> T grab(Component<T> component) {
        boolean missing = !template.has(component);

        if (missing) {
            add(component);
        }

        return get(component);
    }

    /**
     * Dynamically adds the given controller to this Entity. If this Entity
     * already has this controller exactly, this method has no affect. If this
     * Entity already has an alternative to this controller, then this method
     * will still create a template and replace the alternative with the
     * controller given. If this Entity does not already have it's own Template,
     * one will be given. <br/>
     * <br/>
     * This will also enable the controller. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively.
     *
     * @param controller The controller to add or to replace the alternative with.
     */
    public void add(Controller controller) {
        setTemplate(template.addCustomController(controller));

        controllerEnabled.set(template.indexOf(controller));
    }

    /**
     * Dynamically sets the view of this Entity. If this Entity already has this
     * view exactly, this method has no affect. If this Entity already has an
     * alternative to this view, then this method will still create a template
     * and replace the alternative with the view given. If this Entity does not
     * already have it's own Template, one will be given. <br/>
     * <br/>
     * If the view given is a new one, the {@link #setRenderer(Renderer)} method
     * of this Entity will be invoked with the renderer on the given view. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively.
     *
     * @param view The view to set on this Entity.
     */
    public void setView(View view) {
        if (setTemplate(template.setCustomView(view))) {
            setRenderer(template.createRenderer());
        }
    }

    /**
     * Dynamically adds an aliased component to this Entity. This ensures when
     * any component methods (like {@link #get(Component)}) are invoked with the
     * alias component, the subject component will actually be used. If this
     * Entity already has the alias added, then this method has no affect. <br/>
     * <br/>
     * Any dynamic modification to an Entity is not recommended if minimal
     * memory usage is a top priority with the application. Every dynamic entity
     * has it's own template which takes up more memory than it needs to. An
     * ideal system defines all templates and uses them exclusively.
     *
     * @param subject The component to use when alias is passed in to component methods.
     * @param alias   The component which appears to be on this Entity, but isn't.
     */
    public <T> void alias(Component<T> subject, Component<T> alias) {
        setTemplate(template.setCustomAlias(subject, alias));
    }

    /**
     * Sets the renderer of this Entity. If this entity already has a Renderer,
     * this Entity is removed from it by calling
     * {@link Renderer#destroy(Entity)}. The renderer of this entity is set
     * to the value of {@link Renderer#create(Entity)} if newRenderer is not
     * null.
     *
     * @param newRenderer The new renderer of this Entity.
     */
    public void setRenderer(Renderer newRenderer) {
        if (renderer != newRenderer) {
            if (renderer != null) {
                renderer.destroy(this);
            }

            renderer = (newRenderer == null ? null : newRenderer.create(this));
        }
    }

    /*
     * Cloning
     */

    /**
     * Creates a deep or shallow clone of this Entity. A deep clone is an exact
     * replica of this Entity but the component values are independent - if you
     * change one it doesn't change on the parent entity. A shallow clone
     * has the same component value references, so a change to one changes the
     * other.
     *
     * @param deep True for a deep clone, false for a shallow clone.
     * @return A new Entity that is a clone of this Entity.
     */
    public Entity clone(boolean deep) {
        return cloneState(new Entity(template, template.createClonedValues(values, deep), renderer));
    }

    /**
     * Clones the state of this entity to the given entity.
     *
     * @param e The entity to clone this Entity's state to.
     * @return The given entity e.
     */
    protected <E extends Entity> E cloneState(E e) {
        e.controllerEnabled.clear();
        e.controllerEnabled.or(controllerEnabled);
        e.enabled = enabled;
        e.visible = visible;

        return e;
    }

    /**
     * Performs a dynamic merging of a given entity into this Entity. All
     * components, controllers, and view on the given entity that don't exist
     * in this entity are dynamically added and set to this Entity. If
     * overwrite is specified, then the components that are on the given Entity
     * are forcefully added overwriting any alternatives that exist on this
     * Entity.
     *
     * @param entity    The entity to merge into this Entity.
     * @param overwrite True if the entity to merge should force it's specific component,
     *                  controller, and view implementations onto this Entity.
     * @return The reference to this Entity.
     */
    public Entity merge(Entity entity, boolean overwrite) {
        Template template = entity.template;

        for (Component<?> component : template.components) {
            if (overwrite || !has(component)) {
                add(component);
            }
        }

        for (Controller controller : template.controllers) {
            if (overwrite || !has(controller)) {
                add(controller);
            }
        }

        if (overwrite || !hasView()) {
            setView(template.view);
        }

        return this;
    }

    /**
     * The {@link Template} of this Entity. The template contains all meta-data
     * about the components, controllers, and view on this Entity. This template
     * may be the template passed into the constructor, or it may be a template
     * dynamically created when a dynamic method (like {@link #add(Component)})
     * was invoked on a new component/controller/view.
     *
     * @return The reference to the Template of this Entity.
     */
    public Template getTemplate() {
        return template;
    }

    /**
     * Determines whether this Entity has a custom template (which is true for
     * entities that have had components, controllers, or views dynamically
     * added to them).
     *
     * @return True if this is a custom entity, otherwise false.
     */
    public boolean isCustom() {
        return template.isCustom();
    }

    /**
     * Returns the distinct values of this Entity. The order of these values is
     * dependent on the order of distinct components added to this Entity's
     * template. The returned value should not be modified.
     *
     * @return The reference to the array backing this Entity's distinct values.
     */
    public Object[] getValues() {
        return values;
    }

    /**
     * The BitSet of controllers that are active on this Entity. The returned
     * value should not be modified.
     *
     * @return The reference to the enabled controller flags {@link BitSet}.
     */
    public BitSet getControllerFlags() {
        return controllerEnabled;
    }

    /**
     * Returns the number of entities within this Entity. This should always be
     * at least one since this Entity is included in the size.
     *
     * @return The number of entities in this Entity (including this).
     */
    protected int getEntitySize() {
        return 1;
    }

    /**
     * Returns the reference to the entity at the given position within this
     * Entity. The index must be greater than or equal to 0 and less than
     * {@link #getEntitySize()}.
     *
     * @param index The index of the entity to return.
     * @return The reference to the entity at the given index.
     */
    protected Entity getEntity(int index) {
        return this;
    }

    /**
     * Returns the index that when passed into {@link #getEntity(int)} will
     * return the reference to this Entity.
     *
     * @return The index of this entity.
     */
    protected int getEntityIndex() {
        return 0;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();

        sb.append('[');

        if (template != null) {
            for (Component<?> c : template.components) {
                if (sb.length() > 1) {
                    sb.append(',');
                }

                sb.append(c.name);
                sb.append('=');
                sb.append(get(c));
            }
        } else {
            sb.append("DELETED");
        }

        sb.append(']');

        return sb.toString();
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;

        for (Component<?> c : template.components) {
            Object v = get(c);

            result = prime * result + (v == null ? 0 : v.hashCode());
        }

        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null || !(obj instanceof Entity)) {
            return false;
        }
        if (obj == this) {
            return true;
        }

        Entity e = (Entity) obj;

        // First check they both have the same components.
        if (!template.componentBitSet.equals(e.template.componentBitSet)) {
            return false;
        }

        // Iterate through all components, compare values.
        for (Component<?> c : template.components) {
            if (!EntityUtility.equals(get(c), e.get(c))) {
                return false;
            }
        }

        return true;
    }

}
